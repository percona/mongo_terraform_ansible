---
- name: Gather facts from the config servers
  hosts: cfg
  gather_facts: yes
  tags: mongos
  tasks:
    - name: Dummy task to force fact gathering
      debug:
        msg: "Facts collected for cfg servers"

- name: Install mongos routers
  hosts: mongos
  become: yes
  tags: mongos
  environment:
    PERCONA_TELEMETRY_DISABLE: "{{ '1' if disable_telemetry else '0' }}"
  tasks:    
    - name: Install packages from local filesystem
      block:
        
        - name: copy files
          copy:
            src: "{{ mongos_local_package_location }}"
            dest: "{{ mongos_target_package_location }}"

        - name: Find and register copied packages
          find:
            paths: "{{ mongos_target_package_location }}"
            patterns:
              - "*.rpm"
              - "*.deb"
          register: copied_packages  

        - name: Get the paths of copied files
          set_fact:
            mongos_package_list: "{{ copied_packages.files | map(attribute='path') | list }}"      

        - name: Install copied RPM packages (RedHat)
          yum:
            name: "{{ mongos_package_list }}"
            state: present
            disablerepo: "*"
          when:
            - ansible_os_family == 'RedHat'

        - name: Install copied DEB packages (Debian/Ubuntu)
          apt:
            deb: "{{ item }}"
            state: present
          loop: "{{ mongos_package_list }}"
          when:
            - ansible_os_family == 'Debian'

      when: copy_files | bool

    - name: Install mongos from repository
      block:
        - name: Enable specific MongoDB version
          shell: "/usr/bin/percona-release enable {{ mongo_release }}"

        - name: Install mongos packages from repository
          package:
            name: "{{ item }}"
            state: present
          with_items: "{{ mongos_packages }}"

      when: not copy_files | bool

    - name: Disable Percona telemetry
      systemd:
        name: percona-telemetry-agent
        enabled: false
        state: stopped
        daemon_reload: yes
      ignore_errors: true
      when: disable_telemetry | bool

    - name: Create logs directory for mongos 
      file:
        path: "{{ mongod_log_path }}"
        state: directory
        mode: '0755'
        owner: mongod
        group: mongod

    - name: Set up an alias to login easily to mongos
      become: yes
      lineinfile:
        dest: /etc/profile
        line: alias mongo='mongosh admin {% if use_tls %}--tls --tlsCertificateKeyFile {{ certificateKeyFile }} --tlsCAFile {{ certificateKeyFile }} --tlsAllowInvalidCertificates{% endif %} -u {{ mongo_admin_user }} -p {{ mongo_admin_password }} --port {{ mongo_port }} --host {{ ansible_fqdn }}'
        state: present

    - name: Set up shared mongo keyfile 
      become: yes
      copy:
        dest: "{{ keyFile_location }}"
        content: "{{ keyfile_content }}"
        owner: mongod
        group: root
        mode: 0600
      when: not use_tls | bool

    - name: Copy mongos.conf
      template:
        src: templates/mongos.conf.j2
        dest: /etc/mongos.conf
        owner: root
        group: root
        mode: 0644

    - name: Setup logrotate conf for mongos
      template:
        src: templates/logrotate-mongos.conf.j2
        dest: /etc/logrotate.d/mongos
        mode: 0644

    - name: Copy systemd template file for mongos
      template:
        src: templates/mongos.service.j2
        dest: /usr/lib/systemd/system/mongos.service
        mode: 0644

    - name: Set SELinux to disabled until reboot
      command: /usr/sbin/setenforce 0
      when: ansible_selinux.status == "enabled"
      ignore_errors: yes

    - name: Disable SELinux permanently
      lineinfile:
        path: ansible_facts['selinux']['config_file']
        regexp: '^SELINUX='
        line: 'SELINUX=disabled'
      when: ansible_facts['selinux'] is defined and ansible_facts['selinux']['config_file'] is defined

    - name: Start the mongos router service
      systemd:
        name: mongos
        state: restarted
        enabled: yes
        daemon_reload: yes
